// ----- ELEMENTARY FNS ------

atom(x) // return true if x is an atom
eq(x,y) // return true if x==y. both args must be atoms
car(x) // get left child. x must be a list
cdr(x) // get right child. x must be a list
cons(x,y) // return {left:x, right:y}

ff(x) // leftmost atom in x
subst(x,y,z) // find all y (atom) in z, replace by x
equal(x,y) // deep compare x==y
null(x) // true if x is NIL

cadr(x) // car(cadr(x)). go right then left
    // from r towards c. d=right, a=left

append(x,y) // (a,b), (c,d,e) -> (a,b,c,d,e)
among(x,y) // returns true if x is in y (list)
pair(x,y) // (a,b), (c,d) -> ((a,c), (b,d))
assoc(x,y) // x, ((x,a),(y,b)) -> a
            // in js, get y[x]
sublis(x,y) // make changes on expr y according to
    // pairs in x. like subst but multiple.

appq(x) // (a,b) -> ((QUOTE,a), (QUOTE,b))
apply(f,args) // f, (a,b) -> (eval, f, (QUOTE,a), (QUOTE,b))
list(x,y,...z) // forms list (x,y,.... z) 


// eval fn:

atom [e] → assoc [e; a];
atom [car [e]] → [
    eq [car [e]; QUOTE] → cadr [e]; // (QUOTE, ARG) -> ARG
    eq [car [e]; ATOM] → atom [eval [cadr [e]; a]]; // (ATOM, (QUOTE, A)) -> T
    eq [car [e]; EQ] → [eval [cadr [e]; a] = eval [caddr [e]; a]]; // (EQ, (QUOTE, A), (QUOTE, B)) -> F
    eq [car [e]; COND] → evcon [cdr [e]; a];
    eq [car [e]; CAR] → car [eval [cadr [e]; a]]; // (CAR, (QUOTE, (A,B,C))) -> A
    eq [car [e]; CDR] → cdr [eval [cadr [e]; a]]; // (CDR, (QUOTE, (A,B,C))) -> (B,C)
    eq [car [e]; CONS] → cons [eval [cadr [e]; a]; eval [caddr [e]; a]]; // (CONS, (QUOTE, A), (QUOTE, (B,C))) -> (A,B,C)
    T → eval [cons [assoc [car [e]; a]; evlis [cdr [e]; a]]; a]
];
eq [caar [e]; LABEL] → eval [
        cons [caddar [e]; cdr [e]];
        cons [list [cadar [e]; car [e]]; a]
    ];
eq [caar [e]; LAMBDA] → eval [
        caddar [e];
        append [
            pair [
                cadar [e];
                evlis [cdr [e]; a];
            ];
            a
        ]
    ]


/*
    it seems like all except QUOTE first evaluate their args...
    
    (QUOTE, A, B) -> A. B is ignored.
    (ATOM, A, B) -> eval(A). B is ignored. So do (ATOM, (QUOTE, A)) to get A.
    (EQ, A, B) -> eq(eval(A), eval(B)). So values of A, B are compared.
    if you do (EQ, (QUOTE, A), (QUOTE, B)) then you just compare A==B? it gives F.

    (f, a, b) -> eval(eval(f), eval(a), eval(b)). here f should be turned to lambda.
    evlis:
    (A, B, C) -> (eval(A), eval(B), eval(C))

    for lambda stuff, format is
    (
        (LAMBDA, (X,Y), (+,X,Y)), a, b
    )

    so we first eval a and b. Then we eval (+,X,Y) part with extended variable list
    to extend variable list, we use pair((X,Y), (1,2))
    and we get ((X,1),(Y,2)). then we append this to a (variable list)


    cond thing:
    (COND, (X=A,1), (X=B,2), (T,3)) returns either 1, 2 or 3.

    label thing:
    we basically do eval but change both expr and variable list.
    expr is originally ((LABEL, f, Lx.x), (QUOTE, A)).
    it becomes (Lx.x, (QUOTE, A)).
    variable list is originally ((A,1),(B,2)).
    it becomes ( (f,(LABEL,f,Lx.x)), (A,1), (B,2) )

*/

/*

(LABEL,
SUBST,
(LAMBDA, (X, Y, Z),
    (COND,
        ((ATOM, Z),
            (COND,
                ((EQ, Y, Z), X),
                ((QUOTE, T), Z)
            )
        ),
        ((QUOTE, T),
            (CONS, (SUBST, X, Y, (CAR, Z)), (SUBST, X, Y, (CDR, Z)))
        )
    )
)
)

*/